---
title: "DCM_investigation"
author: "MAST"
date: "February 20, 2020"
output: 
  github_document:
    toc : yes
    #number_sections: yes
    fig_width : 8
    fig_height : 6
    #keep_tex : yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, fig.height=4)
library(dplyr)
library(plyr)
#library(plotly)
library(grid)
library(gridExtra)
library(processx)
library(lubridate)
library(plyr)
library(ggplot2)
library(latex2exp)
library(pracma)
```

```{r data}
# Load a bunch of data previously computed
# load(file='../wetransfer-fcfe00/data.RData')

load(file='../dataJune2020.RData')

freshstart = FALSE
```

# Validation HPLC ...

# Morphology of the Black Sea Deep Chlorophyll Maximum

The vertical CHl distributions is first explored here by classifying profiles in terms of analytical shape,
in order to identify a subset of profiles presenting DCM signatures.
Despite the use of an adjusted R-squared metric to classify the Chla profiles, it seems that the plasticity of the sigmoid-gaussian formulation provides a best fit in most cases, both for DCMs (Fig. 3a) and non-DCMs (Fig. 3b) profiles.

Non-DCM profiles dominates from October to April.
No cases of exponential profiles are observed. 
The pure sigmoid profiles, denoting a well-homogenized plantkonic biomass in the surface
layer, happen from October to April with a clear peak in December/January consistent with the known dynamic of the mixed
layer depth in the Black Sea (Capet et al., 2014).

DCMs profiles starts to dominate from April to September.
First DCM profiles are recognized as GS and partly GE. 
Only from July, some profiles depicts a pure gaussian shape, denoting a depletion of surface Chla content.
* In principle corresponds to periods where subsurface CHL content is max?*

```{r nicehistogram}
# compute stats per months
tmp_fit <- filter(init_fit, year %in% c(2014:2019)) # remove 2014 
stats_month <- ddply(tmp_fit, ~month, summarize,
                      profiles = length(unique(juld)))

non_dcm <- filter(tmp_fit, !juld %in% unique(fit$juld))
dcm <- filter(tmp_fit, juld %in% unique(fit$juld))

# rename shapes in 'dcm'
# PAS COMPRIS POURQUOI J'AI GALÉRÉ AUTANT
#dcm$shape <- gsub('GS', 'GS_true', dcm$shape) # M'ONT BIEN CASSÉ LES *** LES LEVELS (merci https://stackoverflow.com/questions/21187603/replace-characters-from-a-column-of-a-data-frame-r)

dcm$shape <- gsub('GS', 'GS_true', dcm$shape) 
dcm$shape <- gsub('GE', 'GE_true', dcm$shape)
dcm[dcm$shape == "G",]$shape <- "G_true"

#put it all back in a single fit dataframe
tmp_fit <- rbind(non_dcm, dcm)

stupid <- ddply(tmp_fit, ~month~shape, summarize,
                count = length(unique(juld)),
                count2 = length(unique(juld)))

#stupid2
for (i in c(1:12)){
  stupid[stupid$month == i,]$count <- stupid[stupid$month == i,]$count/stats_month$profiles[i]
  stupid[stupid$month == i,]$count2 <- stats_month$profiles[i]
}

# define colours (avec le "O" shape entre les deux Arthur?)
# https://www.thinkingondata.com/something-about-viridis-library/
# 
#myColors <- c("#440154FF", "#404788FF", "#287D8EFF", "#3CBB75FF","#DCE319FF") #based on viridis (https://www.thinkingondata.com/something-about-viridis-library/)
# https://bhaskarvk.github.io/colormap/
myColors <- c("#13306DFF", "#6B4596FF", "#403891FF", "#042333FF", "#A65C85FF", "#EB8055FF", "#F9B641FF", "#E8FA5BFF")
#myColors <- brewer.pal(5,"Set1") # can be modified for other colours
names(myColors) <- c("G", "GE", "GS", "S", "O", "G_true", "GS_true", "GE_true") #https://stackoverflow.com/questions/6919025/how-to-assign-colors-to-categorical-variables-in-ggplot2-that-have-stable-mappin
colScale <- scale_fill_manual(name = "shape",values = myColors)

library(scales)
# https://askcodez.com/ggplot-remplace-count-avec-un-pourcentage-dans-geom_bar.html

mylabs<-lapply(seq(12), function(i){paste0(month.abb[i],'\n',format(ddply(tmp_fit, ~month, summarize,
                count = length(unique(juld)))$count[i]))})

  
ggplot(stupid, aes(x = month, fill = shape, y = count)) +
  geom_bar(stat='identity') +
  theme_bw() + 
  scale_x_continuous(breaks = c(1:12), labels = mylabs,name='') +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), labels = scales::percent(c(0,0.25,0.5,0.75,1)),name='') +
  scale_fill_manual(name = "Best-fitting Form",values = myColors,
                    labels=list("non-DCM : Sigmoïd",
                                "non-DCM : Gaussian-Sigmoïd",
                                "non-DCM : Gaussian-Exponential",
                                "non-DCM : Gaussian",
                                "Others",
                                "DCM : Gaussian-Sigmoïd",
                                "DCM : Gaussian-Exponential",
                                "DCM : Gaussian"))

```



# Seasonal Time-Series

```{r Processing, error=FALSE, warning=FALSE, echo=FALSE, message=FALSE, results='hide', include=FALSE, eval=TRUE}
# Prepare data for Temporal Series
if (freshstart){
  
tmp <- init_profiles
tmp_fit <- init_fit

## MODIF to avoid ordering errors ##
#tmp_fit$dcm_or_not <- NA
fit$dcm_or_not <- 1
tmp_fit <- merge(tmp_fit, fit[,c('juld','platform','dcm_or_not')],by=c('juld','platform'), all = TRUE)
tmp_fit$dcm_or_not[is.na(tmp_fit$dcm_or_not)]<-0
#tmp_fit$dcm_or_not[which(tmp_fit$juld %in% fit$juld)] <- "DCM"
####


# Add scalr diagnostics to the complete dataframe for vertical integration
complete_tmp <- merge(tmp,tmp_fit[,c('juld','platform','MLD','Zmax','Zdemi')], by=c('juld','platform'))


#### This is making trouble .; probably because depth of light and other measurement are different.. 
#complete_tmp_par <- merge(complete_tmp,
#                          initPAR[,c('depth','juld','par','platform')],
#                          by=c('depth','juld','platform'),
#                          all.x=TRUE)

optical_depth <- c(6,6,6,7.5,7,7,7.5,9,8,6.5,6,6) #1/k = optical depth ==> we have a value for each month

}
```


```{r Functions, error=FALSE, warning=FALSE, echo=FALSE, message=FALSE, results='hide', include=FALSE, eval=TRUE}
############
# Functions to apply to profiles
############

# Attempt for uniroot.. not working for now. 
content_z<-function(z, depth, fluo,total){
  print(paste0('my total is', as.character(total)))
  ztot <- sum(approx(x=depth, y=fluo,xout = seq(0,z), rule = 2)$y, na.rm=T)
  print(paste0('my local total for Z:',as.character(z),'is', as.character(ztot)))
  diff <- 0.9*total-ztot
  return (diff)
}

# Stupid function to find the lower boundary of core X% CHL content.
depth90B<-function(depth, fluo, total,p=.9){
#  print(total)
  # return the depth over which integration should be doe to capture 95 % of the total CHL content.
  loctot<-0
  z90 <-14
  while(loctot<p*total){
      z90=z90+1
      loctot = sum(approx(x=depth, y=fluo,xout = seq(0,z90), rule = 2)$y, na.rm=T)
  }
  return(z90)
}

depth90T<-function(depth, fluo, total,p=.9){
#  print(total)
  # return the depth over which integration should be doe to capture 95 % of the total CHL content.
  loctot<-0
  z90 <-100
  while(loctot<p*total){
      z90=z90-1
      loctot = sum(approx(x=depth, y=fluo,xout = seq(z90,200), rule = 2)$y, na.rm=T)
  }
  return(z90)
}


#########
# Light #
#########

grad_att <- function(PRESr,k,PAR0){
  PAR<-PRESr*0
  kint<-(c(k[1],k)+c(k,k[length(k)]))/2
  PAR[1]<-PAR0*exp(-kint[1]*PRESr[1])
  for (i in 2:length(PAR)){
    PAR[i]<-PAR[i-1]*exp(-((kint[i]+kint[i])/2    )*(PRESr[i]-PRESr[i-1]))
  }
  return(PAR)
}

Att_2band <- function(PRES,PAR0,ks0,kl0,depthP0=0) {
  ##  "CHL_2BANDS" ##
  # CHLA specific attenuation + two bandwidths
  if (depthP0 !=0){
    PAR0  = PAR0/(parts*exp(-ks0*depthP0)+(1-parts)*exp(-kl0*depthP0)  ) 
  }
  PAR0s <- PAR0*parts
  PAR0l <- PAR0*(1-parts)
  ks    <- rep(ks0,length(PRES))
  kl    <- rep(kl0,length(PRES))
  PARs  <- grad_att(PRES,ks,PAR0s)
  PARl  <- grad_att(PRES,kl,PAR0l)
  PAR<-PARs+PARl
  return(PAR)
}

p2b_start = c(PAR0 = 1500 ,  ks0 = 0.04 , kl0=0.001) 
p2b_lower = c(PAR0 = 0    ,  ks0 = 0    , kl0=0    )
p2b_upper = c(PAR0 = 2500 ,  ks0 = 3   , kl0=10)

Out_Default <- data.frame("PAR0"=NA,
                          "ks0"=NA,
                          "kl0"=NA)
parts = 0.37
DefOut_isoPAR <-NA


## Filter function to select eligible profiles
#countcheck<-1
FilterForPAR<-function(depth,PAR){
 # countcheck<<-countcheck+1
  # if (countcheck<10){
  #   print(depth)
  #   print(PAR)
  #   print(sum(is.na(PAR))>length(PAR)/2)
  #   readline(prompt="Press [enter] to continue")
  # }
  return (sum(is.na(PAR))<length(PAR)/2)
}

## First attempt derives APR @ 1m from interpolation and look for 1/100 of this value
isoPAR <- function(depth, PAR){
  require(pracma)
  # Intended for Casted DF
  if (FilterForPAR(depth,PAR)){
    out    <- try_default({
    d <- depth[which( !is.na(depth) & PAR>0.1  )]
    P <- PAR[which( !is.na(depth) & PAR>0.1  )]
             p1 <-interp1(d,P, 1)      
      z100 <- interp1(P,d, p1/100) 
      return(z100)},
      DefOut_isoPAR)
  }else{
    out <- DefOut_isoPAR
  }
  return(out)
}

## Second option 
isoPARb <- function(depth, PAR){
  require(pracma)
  # Intended for Casted DF
  if (FilterForPAR(depth,PAR)){
    out    <- try_default({
    d <- depth[which( !is.na(depth) & PAR>0.1  )]
    P <- PAR[which( !is.na(depth) & PAR>0.1  )]
    
    m <<-nls(PAR ~ Att_2band(depth,PAR0,ks0,kl0),
           data = data.frame(depth=depth, PAR=PAR),
           start = p2b_start, 
           lower = p2b_lower,
           upper = p2b_upper,
           algorithm = "port", 
           control = list(maxiter= 1000)
           )
    mcoef  <<- coef(m)
    PAR0   <-mcoef[1]
    PARcon <- predict(m,data.frame(depth=seq(1,200)))    
    z100 <- interp1(PARcon,seq(1,200), PAR0/100) 
      return(z100)},
      DefOut_isoPAR)
  }else{
    out <- DefOut_isoPAR
  }
  return(out)
}

# PAR2bands <- function(profile){
#   # Intended for Casted DF
#   if (FilterForPAR(profile)){
#     out <-try_default({
#       m   <-nls(PAR ~ Att_2band(depth,PAR0,ks0,kl0),
#           data = profile,
#           start = p2b_start, 
#           lower = p2b_lower,
#           upper = p2b_upper,
#           algorithm = "port", 
#           control = list(maxiter= 1000)
#           )
#       return(as.data.frame(t(coef(m))))},
#     Out_Default)
#   }else{
#     out <- Out_Default
#   }
#   return(out)
# }


# depth90b<-function(depth, fluo, total){
#   # return the depth over which integration should be doe to capture 95 % of the total CHL content.
#   print(total)
#   print(content_z(20, depth=depth, fluo=fluo, total=total))
#     print(content_z(30, depth=depth, fluo=fluo, total=total))
#       print(content_z(40, depth=depth, fluo=fluo, total=total))
#   z90=uniroot(content_z,c(10,200), depth=depth, fluo=fluo, total=total,tol = 1)
#   print(z90)
#   return(z90)
# }
```


```{r light integrated diags, error=FALSE, warning=FALSE, echo=FALSE, message=FALSE, results='hide', include=FALSE, eval=TRUE}

# To compute light diagnostics, ie. iso 1% of surface PAR. 
## Two methods are operational. (see functions isoPAR and isoPARb)
## At the moment, the second one allows more values, as the first one is not working when no light data are available near-surface.

if (freshstart){
integrated_diags_par <- ddply(initPAR, .(juld,platform), summarize,
                          Ziso1 = isoPAR(depth = depth , PAR = par),
                          Ziso1b = isoPARb(depth = depth , PAR = par)
                          )
}

```

```{r}
# Add scalr diagnostics to the complete dataframe for vertical integration
if (freshstart){
complete_tmp2 <- merge(complete_tmp,integrated_diags_par, by=c('juld','platform'), all.x = TRUE)
}

```


```{r IntegratedDiagsdf, error=FALSE, warning=FALSE, echo=FALSE, message=FALSE, results='hide', include=FALSE, eval=TRUE}
# TOTAL CHL, integration using first linear interpolation on a regular grid, then sum.
if (freshstart){
integrated_diags <- ddply(complete_tmp2, .(juld,platform), summarize,
                          # TOTAL CHL, integration using first linear interpolation on a regular grid, then sum.
                            total_chla    = sum(approx(x=depth, y=fluo,xout = seq(0,200), rule = 2)$y, na.rm=T),
                          # chl content relative to MLD depth
                            DoMLD_chla    = sum(approx(x=depth, y=fluo,xout = seq(0,200), rule = 2)$y[round(unique(MLD)):200]),
                            UpMLD_chla    = sum(approx(x=depth, y=fluo,xout = seq(0,200), rule = 2)$y[  0:round(unique(MLD))]),
                            RaMLD_chla    = UpMLD_chla/total_chla*100,
                          # Visible part based on monthly optical depth
                            optic_depth   = optical_depth[unique(month)]*3,
                            visible_chla  = sum(approx(x=depth, y=fluo,xout = seq(0, optic_depth), rule = 2)$y, na.rm=T), 
                            visible_ratio = visible_chla/total_chla*100, 
                          # Content around DCM 
                            DCMcontent    = try_default(
                              sum(approx(x=depth, y=fluo,xout = seq(round(unique(Zmax)-10), round(unique(Zmax)+10)), rule = 2)$y, na.rm=T),
                              NA, quiet = FALSE), 
                            DCMratio      = DCMcontent/total_chla*100 ,
                          # sigma @ Zdemi 
                          # by definition, sigma @ MLD follows sig surface by a fixed amont. 
                            #sigmaMLD      = sigma[which.min(depth)],
                            ZLow           = min(depth[fluo<0.01]),
                          #  Z90           = depth90b(depth = depth , fluo = fluo,total = total_chla),
                            Z90B           = depth90B(depth = depth , fluo = fluo,total = total_chla, p=0.75),
                            Z90T           = depth90T(depth = depth , fluo = fluo,total = total_chla, p=0.75),
                            sigmalow       = try_default(approx(x=depth, y=sigma, xout=ZLow, rule=2)$y,NA, quiet = FALSE),
                            sigma90B       = try_default(approx(x=depth, y=sigma, xout=Z90B, rule=2)$y,NA, quiet = FALSE),
                            sigma90T       = try_default(approx(x=depth, y=sigma, xout=Z90T, rule=2)$y,NA, quiet = FALSE),
                            sigmaMLD       = min(sigma, na.rm = TRUE),#[which.min(depth)],  !! THIS IS NOT CORRECT !!
                            sigmaMAX       = try_default(approx(x=depth, y=sigma, xout=unique(Zmax), rule=2)$y,NA, quiet = FALSE),
                            sigmaDEMI      = try_default(approx(x=depth, y=sigma, xout=unique(Zdemi), rule=2)$y,NA, quiet = FALSE), 
                            #Ziso1         = isoPAR(depth = depth , PAR = par),
                            sigmaiso1      = try_default(approx(x=depth, y=sigma, xout=unique(Ziso1b), rule=2)$y,NA, quiet = FALSE)
                          )
}
```


```{r IntegratedDiagsMerge, error=FALSE, warning=FALSE, echo=FALSE, message=FALSE, results='hide', include=FALSE, eval=TRUE}
if (freshstart){
# !!!!! Carefull here, this is much cleaner that the following commented line
# which does not ensure that the order corresponds, only hte number of elements !!!!!!
# Took me a while to track why this was causing different results !! 
tmp_fitc<-merge(tmp_fit ,integrated_diags, by = c('juld','platform'))

tmp_fitc<-merge(tmp_fitc ,integrated_diags_par, by = c('juld','platform'), all.x = TRUE)
#tmp_fit$total_chla_content <- total_chla_content$total_chla

# remove 2014 .. (not enough data) or not.
tmp_fitc   <- tmp_fitc[tmp_fit$year %in% c(2014:2019),]

tmp_my <- ddply(tmp_fitc, .(month,year), summarize,
                nprof = length(dcm_or_not),
                percentage_dcm =  sum(dcm_or_not)/length(dcm_or_not)*100
                ) 
}
```



```{r}
# Just to save time when kniotting multiple times. 
if (freshstart) {
 save.image(file='./CleanResultsData.RData') 
}else{
load(file='./CleanResultsData.RData')
}
```


To avoid overinterpreting in winter, we remove for DCM characs, the months for which percentage DCM is below 50.
So diagnostics based on DCM criterion are cancelled for those periods for which DCM dynamics is not representative.
```{r}

tmp_fitco<- tmp_fitc
tmp_fitco$dcm_or_not[tmp_fitco$shape=="O"]<-1
tmp_fitc[which((tmp_fitc$month<4)|(tmp_fitc$month>10)),c('Zmax','sigmaMAX','DCMratio')]<-NA
tmp_fitco[which((tmp_fitco$month<4)|(tmp_fitco$month>10)),c('Zmax','sigmaMAX','DCMratio','chla_dcm')]<-NA
#tmp_fitco[which((tmp_fitco$month<4)|(tmp_fitco$month>10)),c('Zmax','sigmaMAX','DCMratio')]<-NA
```


# Back Scattering Validation of the DCM -> DPM relation

I want to use backscattering values, to comment on the fact that DCM correspond to a maximum in DBM, or relates on to another in some ways. 

## First Approach. 

* I'll use all DCM profiles
* I'll normalize them using 
    * CHL@DCM to normalize chl
    * z@DCM to normalize the vertical scale. 
* Plot this, plot bbp on the same normalized axis. 
    
```{r}
dbdf<- subset(complete_tmp2, select = c('juld','platform','depth','sigma','fluo','bbp','Zmax','month','lon'))
dbdf<-merge(dbdf, subset(tmp_fitc,select = c('juld','platform','dcm_or_not','chla_dcm','sigmaMAX','sigmaMLD','MLD')), by = c('juld','platform'))
dbdf<- subset(dbdf,dcm_or_not==1)

dbdf<-subset(dbdf, (month>2)&(month<11))
dbdf<-subset(dbdf, !is.nan(Zmax))

dbdf$fluo_norm <- dbdf$fluo/dbdf$chla_dcm
dbdf$sigma_norm <- (dbdf$sigma-dbdf$sigmaMLD)/(dbdf$sigmaMAX-dbdf$sigmaMLD+.00000001)
dbdf$depth_norm <- (dbdf$depth-dbdf$MLD)/(dbdf$Zmax-dbdf$MLD+.00000001)
#dbdf$depth_norm_layers<-factor(dbdf$depth_norm_layers,levels=rev(levels(dbdf$depth_norm_layers)))

dbdf<-ddply(dbdf,.(platform, juld),mutate,
            bbpmax= max(bbp[depth_norm<1.5]),
            bbp_norm1 = bbp/bbpmax,
            bbp_DCM = approx(depth,bbp,Zmax)$y,
            bbp_norm2 = bbp/bbp_DCM)

dbdf$sigma_norm_layers <- cut(dbdf$sigma_norm,seq(0.05,3.05,.1))
dbdf$depth_norm_layers <- cut(dbdf$depth_norm,seq(0.05,3.05,.1))
```


```{r}
blbl<-subset(dbdf, select=c("sigma_norm_layers","fluo_norm", "depth_norm_layers","depth_norm","sigma_norm","bbp_norm1","month",'lon'))
require(reshape2)
blbl<-melt(blbl, id.vars=.(sigma_norm_layers,depth_norm_layers,month,depth_norm,sigma_norm,lon))

blbl$monthn<-factor(blbl$month, labels = month.abb[unique(blbl$month)])

blbl$variable<-as.character(blbl$variable)
blbl$variable[which(blbl$variable=="fluo_norm")]<-"Chla - norm."
blbl$variable[which(blbl$variable=="bbp_norm1")]<-"Bbp - norm."

blbl$variable<-factor(blbl$variable, levels=c("Chla - norm.","Bbp - norm."))


bigplot1<-ggplot(subset(blbl, month %in% c(3,4,5,6)), aes(x=depth_norm, y=value))+
      geom_boxplot(aes(group=depth_norm_layers), outlier.size=0.5)+
  theme_bw()+coord_flip(xlim = c(0,2), ylim=c(0,1.5))+
  facet_grid(monthn~variable)+
  geom_vline(xintercept  = 1)+xlab('Depth - norm.')+ylab('')

bigplot2<-ggplot(subset(blbl, month %in% c(7,8,9,10)), aes(x=depth_norm, y=value))+
      geom_boxplot(aes(group=depth_norm_layers), outlier.size=0.5)+
  theme_bw()+coord_flip(xlim = c(0,2), ylim=c(0,1.5))+
  facet_grid(monthn~variable)+
  geom_vline(xintercept  = 1)+xlab('Depth - norm.')+ylab('')
```


```{r bigplotbackscat}
grid.arrange(bigplot1+scale_x_reverse(),
             bigplot2+scale_x_reverse(), nrow=1)
```


## Second Approach

Using DBM from analytical fits

```{r}
bothfit<-merge(fit, fit_BBP, by=c("platform", "juld","month",'lon','lat'))

bothfit$monthn<-factor(bothfit$month, labels = month.abb[unique(bothfit$month)])

ggplot(subset(bothfit, (dcm_or_not==1) &
                (r2adj.y>0.95)&
                grepl('G',bothfit$shape.y)&
                (month %in% seq(3,10))),
       aes(x=Zmax.x, y=Zmax.y, color=factor(month)))+
  geom_point()+theme_bw()+ylim(c(-10,60))+xlim(c(-10,60))+geom_abline(slope = 1,intercept = 0)+
  facet_wrap(~monthn)+xlab(TeX('$z_{DCM}'))+ylab(TeX('$z_{DBM}'))
```

# Depth horizons

!!! Probably have to add lights characteristics !!! 

Let's consider $Z_{1/2}$ as indicative of the lower boundary of the depth area with signicant CHL concentration. 
Indeed, Sigmoid gaussian profiles are dominant through the years, with a long tail covering insignifiant CHL values over a large depth range.

**C'est clair ça ? **

The deeper winter MLD bounds the productive area in winter. 
Starting with the stratification onset in March, when MLD goes up, the chloropyll content penetrates deeper, with a rapid creation of DCM.
$Z_{DCM}$ starts at $Z_{1/2}$ (April), dissociate from $Z_{1/2}$ in June, and can't **(?)** be distinguished from $Z_{1/2}$ from July on.


Very low variabiliity of summer MLD, but larger in winter. 
Most probably winter MLD scatter is associated with spatial variability **(can be answered, I mean in regards with interannual variability)**.

```{r depth}
require(reshape2)
MyPal<-'Dark2'

# To remove/add line in the plot below, simply remove/add a variable in the list. (e.g. add 'Zdemi',)
tmp_zmax1 <- subset(tmp_fitco, select = c('month','year','dcm_or_not','shape','MLD','Zmax','ZLow','Z90B','Z90T','Ziso1b'))

tmp_zmax1$Zmax[tmp_zmax1$dcm_or_not==0]<-NA
tmp_zmax1$Zmax[tmp_zmax1$Zmax>200]<-NA
tmp_zmax1$Zdemi[tmp_zmax1$shape %in% c("O","GE","G")]<-NA

tmp_zmax <- melt(tmp_zmax1[,-which(colnames(tmp_zmax1)=='dcm_or_not')], id.vars=c('month','year','shape'))

ggplot(tmp_zmax, aes(x=month, fill=variable, color=variable)) +
    geom_smooth(aes(y=value),stat = 'summary',
#              fun.data = median_hilow,
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
  geom_boxplot(aes(y=value, group=interaction(month,variable)), alpha=0.2, notch = TRUE)+
        scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) +
          scale_y_reverse(breaks = seq(100,0,-10), minor_breaks = NULL) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('[m]')+theme_bw()+coord_cartesian(ylim=c(100,0))+
  #scale_y_reverse()+
    scale_color_brewer(aesthetics = c("colour", "fill"),
                       type = qual ,
                       palette=MyPal,
                       name="Depth Horizons", 
                       labels=list(TeX('$z_{MLD}$'),
                                TeX('$r_{DCM}$'),
                                TeX('$z_{low}$'),
                                TeX('$z_{50,bottom}$'),
                                TeX('$z_{50,top}$'),
                                TeX('$z_{\\mathrm{PAR}\\,1%}$')))
```


## Density Horizons

Density framework shows less spatial variability, and more stable seasonal evolution. 

The deepest winter MLD sets pycnal layer of Z_1/2, which remains stable from February to September.
From may to june, a DCM forms and migrate to higher layers. 

Unlike the previous plot, the pycnal coordinates allow to dissociate DCM from June to September.
This is indicative of pycnal or mixing forces ruling the location of the DCM, rather than restrictevely light conditions wich tend to be more related to the depth [m] scale.

Obviously nutrient content follows isopycnal layers.
Konovalov (2006) locates the nitrate nitracline at 15.5 kg/m3.

Between August and October, it seems the lower part of CHL limited and Sigma_1/2 rejoins Sigma_max. Light limitation by a well formed DCM ? 
Indeed, it's in August that the percentage of CHL around DCM is highest, so that CHL density in the DCM zone is the thickest. 
**Something strange with MLD .. How many defined MLD in summers ? Is there less ? is that what explain low variability in summer?**
**I changed the definition of sigma MLD above, but ... dont get it.**

```{r sigma}
tmp_sig1 <- subset(tmp_fitco, select = c('month','sigmaMLD','sigmaMAX','sigmalow','sigma90B','sigma90T','sigmaiso1' ,'dcm_or_not','year','shape'))

tmp_sig1$sigmaMAX[tmp_sig1$dcm_or_not==0]<-NA
tmp_sig1$sigmaMAX[tmp_sig1$Zmax>200]<-NA
#tmp_sig1$Zdemi[tmp_sig1$shape %in% c("O","GE","G")]<-NA

tmp_sig <- melt(tmp_sig1[,-which(colnames(tmp_sig1)=='dcm_or_not')], id.vars=c('month','year','shape'))


ggplot(tmp_sig, aes(x=month, fill=variable, color=variable)) +
    geom_smooth(aes(y=value),stat = 'summary',
#              fun.data = median_hilow,
              fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
  geom_boxplot(aes(y=value, group=interaction(month,variable)), alpha=0.2, notch = TRUE)+
        scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('[kg/m3]')+theme_bw()+coord_cartesian(ylim=c(16,10))+scale_y_reverse()+
      scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal,
                       name="Density Horizons", 
                       labels=list(TeX('$\\sigma_{MLD}$'),
                                TeX('$\\sigma_{DCM}$'),
                                TeX('$\\sigma_{low}$'),
                                TeX('$\\sigma_{50,bottom}$'),
                                TeX('$\\sigma_{50,top}$'),
                                TeX('$\\sigma_{\\mathrm{PAR}\\,1%}$')))+
  geom_hline( yintercept = 14.5)

## How to maintain all data even those out of axis limits : https://stackoverflow.com/questions/25685185/limit-ggplot2-axes-without-removing-data-outside-limits-zoom


```


## Vertical distribution of the CHL content


In Summer, about 50-60 % (up to 75%) of the total chlorophyll content is located in a narrow 20m band around the DCM. 
This DCM is located between 30-40m, which is about 4 times the optical depth estimated as the inverse of PAR attenuation profiles. 

The question is how much of this is missed by satellite ? 
From May to August, less than 20% of the total Chl content is above the MLD (~)
```{r parts}
require(reshape2)
tmp_part <- melt(subset(tmp_fitco, select = c('month','year','RaMLD_chla','DCMratio')), id.vars=c('month','year'))
#,'visible_ratio'

ggplot(tmp_part, aes(x=month, fill=variable, color=variable)) +
    geom_smooth(aes(y=value),stat = 'summary',
#              fun.data = median_hilow,
              fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
        scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) +
        scale_y_continuous(breaks = seq(0,100,10), minor_breaks = NULL) +
    geom_boxplot(aes(y=value, group=interaction(month,variable)), alpha=0.2)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('[%]')+theme_bw()+
  scale_color_brewer(name='Part of tot. Chl:',
                     labels=c('above MLD','within 5m of DCM','above optical depth'),
                     aesthetics = c("colour", "fill"),type = qual ,palette=MyPal)#+ylim(c(0,100))
```
## Concentrations

Here we compare CHL concentrations at DCM and surface to the average Chl Content. 

Average CLH content is considered by dividing the vertically integrated chla content with a constant scaling depth of 40m, 
chosen as the mean of Z 1/2, as discussed above. 

Except from the hint of a bloom in March, the total CHL content does not
indicate very strong seasonal variations.

Instead, the surface chlorophyll content does decrease by a factor two from April to September, while chl concentrations at DCM are above average.

We note the increase in August, that was suggested to limit CHL at depth in the previous sections (ref{sec_season_sigma}). 


```{r concentrations}
require(reshape2)
tmp_conc1<-subset(tmp_fitco, select = c('total_chla','chla_surf','chla_dcm','month','year','dcm_or_not'))

tmp_conc1$chla_dcm[tmp_conc1$dcm_or_not==0]<-NA

tmp_conc1$total_chla<-tmp_conc1$total_chla/40

tmp_conc <- melt(tmp_conc1[,-which(colnames(tmp_conc1)=='dcm_or_not')], id.vars=c('month','year'))

  ggplot(tmp_conc, aes(x=month, fill=variable, color=variable)) +
      geom_smooth(aes(y=value),stat = 'summary',
  #              fun.data = median_hilow,
                fun.data = mean_cl_boot,
                fun.args = list(conf.int = 0.95), alpha=0.5)+
          scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) +
      geom_boxplot(aes(y=value, group=interaction(month,variable)), alpha=0.2)+
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ylab('[mg/m3]')+theme_bw()+coord_cartesian(ylim=c(0,3.5))+
    scale_color_brewer(aesthetics = c("colour", "fill"),type = qual,
                       palette=MyPal, 
                       name="Chla concentrations",
                       labels=c("Average","Surface","DCM"))
```


# Satellite confrontation 

L4 products obtained from CMEMS.
Match-up extracted from CMEMS satellite products at Argo Locations. 

Decent correlation (0.59, p<1e-13) between satellite CHL and surface CHL from Argo profilers.
Clear multiplicative bias of 2.1 (larger Argo values).

Here we want to discuss in relative terms about the location of the bulk of Chl content, and how the seasonal cycle of Chloropyll can be grasped by satellite. 
In the following, we thus multiply satellite products by a corrective factor of two, in order to compare seasonal evolutions on a similar scale. 
We do not have at our disposal, sufficient in-situ HPLC data to conclude on the absolute value of CHL here, but the relative context is sufficient for our argument.

A very close relationship is observed between Argo and satellite products at colocation points (nothwithstanding the multiplicative bias).
The Argo curve of surface CHl concetration on this figure, is also in agreement with the seasonal behavior described above considering ARGo profiles over a larger period.

**Attention here, we need to discuss Quenching correction, and the fact that Argo profiles do not extend to surface**

```{r Satellite}

source("AddSat.R")
tmp2019 <- subset(tmp_fit,year==2019)
Sat_tmp2019 <- AddSat(tmp2019)

tmp_sa1        <- subset(Sat_tmp2019, select = c('satCHL','chla_surf','month','year'))
tmp_sa1$satCHL <- tmp_sa1$satCHL
tmp_sa         <- melt(tmp_sa1, id.vars=c('month','year'))


ggplot(tmp_sa,aes(x=month, fill=variable, color=variable))+
geom_smooth(aes(y=value),stat = 'summary',
#              fun.data = median_hilow,
              fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
        scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) +
    geom_boxplot(aes(y=value, group=interaction(month,variable)), alpha=0.2)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+theme_bw()+ylab('[mg/m3]')+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal, name="Surface Chla", labels=c("Satellite","Argo"))


```

## Satellite Comparison

```{r Satellite2}
# Used for coef on next plots.
#-summary(lm(satCHL~chla_surf, Sat_tmp2019))

ggplot(Sat_tmp2019,aes(x=chla_surf,y=satCHL,color=factor(month)))+
  geom_point()+theme_bw()+
  #geom_smooth(method='lm')+
  xlim(c(0,1.5))+ylim(c(0,1.5))+
  geom_abline(intercept = 0,slope = 1,size=2)+
  #geom_abline(intercept = 0,slope = .5,linetype=3)+
  xlab("Argo - [mg/m3]")+ylab("Satellite - [mg/m3]")+
  scale_color_discrete(name='', labels=month.abb)
```


```{r Satellite2_coefs}
cor.test(Sat_tmp2019$satCHL,Sat_tmp2019$chla_surf)

rmserr(Sat_tmp2019$chla_surf,Sat_tmp2019$satCHL)
```

# Discussion

## "Correction of Satellite value"
A DCM dynamics dominates from April to October.
Contains about 50-70 % of total chl content.
Due to this seasonal change in the vertical distribution of Chlorophyll, considering only surface information (as for instance provided by satellite) might lead to underestimate summer total chl content by a factor of up to 3.5 in august. 

To estimate this factor, we divided here the average CHL content as defined in Sect. ... (total content/ divided by 40m) by surface content as provided by Argo Floats. 

```{r}
tmp_ra2 <- tmp_conc1

tmp_ra2$surfcorrection <- tmp_ra2$total_chla/tmp_ra2$chla_surf

tmp_corr <- melt(subset(tmp_ra2,select=c('month','year','surfcorrection')), id.vars=c('month','year'))

ggplot(tmp_corr, aes(x=month, fill=variable, color=variable)) +
    geom_smooth(aes(y=value),stat = 'summary',
#              fun.data = median_hilow,
              fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
        scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) +
    geom_boxplot(aes(y=value, group=interaction(month,variable)), alpha=0.2)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('DCM scaling factor')+theme_bw()+scale_y_continuous(limits=c(0,10), breaks = seq(0,10))+
  scale_colour_discrete(guide=FALSE)+scale_fill_discrete(guide=FALSE)
```


## Navarro's Ratio

First, using Flo's approach

```{r sigma ratio 1, echo=TRUE}
# Compute the SIGMA@MAX MLD for each year and each platform
MLDdf_info1 <- ddply(init_MLD, ~year~platform, summarize,
                maxMLD = max(MLD, na.rm = T),
                sigmaMaxMLD = sigmaMaxMLD[which.max(MLD)])

# Compute the sigma_ratio, i.e. SIGMA@DCM/SIGMA@MAX MLD
 sigma_ratio1 <- ldply(as.list(unique(MLDdf$juld)), function(i){
   tmp <- MLDdf[MLDdf$juld == i,]
   tmp2 <- fit[fit$juld == i,]
   tmp3 <- profiles[profiles$juld == i,]
   sigmaMaxMLD <- MLDdf_info1$sigmaMaxMLD[which(MLDdf_info1$year == tmp$year & MLDdf_info1$platform == tmp$platform)]
   sigmaDCM <- approx(tmp3$depth, tmp3$sigma, tmp2$Zmax)$y #interpolation
   ratio = sigmaDCM/sigmaMaxMLD
   data.frame(ratio = ratio, juld = tmp$juld[1], month = tmp$month[1])
 })

# 1. First plot to see the spread in sigma MAX mld (amongst platfrom).
ggplot(MLDdf_info1, aes(x=factor(year), y=sigmaMaxMLD, color=factor(platform)))+geom_point()+scale_y_continuous(limits=c(13.8,15.0))

 ggplot(sigma_ratio1, aes(x=month, y=ratio)) +
    geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
  geom_boxplot(aes(group=month), alpha=0.2, notch = TRUE)+
  theme_bw()+scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12))+
  scale_y_continuous(breaks = seq(0.8,1.2,0.05), minor_breaks = NULL) +
  ylab('sigma@DCM/sigma@MLD_MAX')
```

First, using Art's approach

```{r sigma_ratio_2, echo=TRUE}
require(scales)
# # # # # # # # # # # # # #
 # As I would have done it #

MLDdf_info2 <- ddply(tmp_fitco, .(year,platform), summarize,
                maxMLD = max(MLD, na.rm = T),
                sigmaMaxMLD = max(sigmaMLD, na.rm = T))

sigma_ratio2 <- ddply(tmp_fitco, .(platform, juld), mutate,
   sigmaMaxMLD = MLDdf_info2$sigmaMaxMLD[which((MLDdf_info2$year == unique(year))
                                              & (MLDdf_info2$platform == unique(platform)))],
   ratio = sigmaMAX/sigmaMaxMLD)


ggplot(MLDdf_info2, aes(x=factor(year), y=sigmaMaxMLD, color=factor(platform)))+geom_point()+scale_y_continuous(limits=c(13.8,15.0))

discfig1<-ggplot(sigma_ratio2, aes(x=month, y=ratio)) +
    geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5,color=brewer_pal(palette = MyPal)(2)[1],fill=brewer_pal(palette = MyPal)(2)[1])+
  geom_boxplot(aes(group=month), alpha=0.2, notch = TRUE,color=brewer_pal(palette = MyPal)(2)[1],fill=brewer_pal(palette = MyPal)(2)[1])+
  theme_bw()+scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12))+
  scale_y_continuous(breaks = seq(0.8,1.2,0.05), minor_breaks = NULL) +
  ylab(TeX('$\\sigma_{DCM}/\\sigma_{MLD,max}$'))
print(discfig1)
```


Comparing Both

```{r sigma_ratio_comp, echo=TRUE, include=FALSE}
###
require(reshape2)
M1<-MLDdf_info1[,c('year','platform','sigmaMaxMLD')]
colnames(M1)[3]<-'sigmaMaxMLD_1'
M2<-MLDdf_info2[,c('year','platform','sigmaMaxMLD')]
colnames(M2)[3]<-'sigmaMaxMLD_2'

MM <- merge(M1,M2,by=c('year','platform'))

ggplot(MM, aes(x=sigmaMaxMLD_1, y=sigmaMaxMLD_2, color=factor(platform), shape=factor(year)))+geom_point()

s1<-subset(sigma_ratio1,select = c("month", "ratio"))
colnames(s1)[2]<-'ratio_1'
s2<-subset(sigma_ratio2,select = c("month", "ratio"))
colnames(s2)[2]<-'ratio_2'

ss <- merge(s1,s2,by=c('month'))
ss <- melt(ss,id.vars=c("month"))

ggplot(ss, aes(x=month, y=value, fill=variable, color=variable))+
  geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
             fun.data = mean_cl_boot,
             fun.args = list(conf.int = 0.95), alpha=0.5)+
  geom_boxplot(aes(group=interaction(month,variable)),
               alpha=0.2, notch = TRUE)+
  theme_bw()+scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12))+
  scale_y_continuous(breaks = seq(0.8,1.2,0.05), minor_breaks = NULL) +
  ylab('sigma@DCM/sigma@MLD_MAX')

```

Interannual checkup
```{r ratio_interannual, include=FALSE}

sigma_ratio2d<-ddply(sigma_ratio2,.(platform, juld), mutate,
                    mY = dmy(paste0("15",sprintf("%02d",month),year)))

ggplot(sigma_ratio2d, aes(x=mY, y=ratio)) +
    geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
  geom_boxplot(aes(group=mY), alpha=0.2, notch = TRUE)+
  theme_bw()+
  scale_y_continuous(breaks = seq(0.8,1.2,0.05), minor_breaks = NULL) +
  ylab('sigma@DCM/sigma@MLD_MAX')

ggplot(sigma_ratio2d, aes(x=mY, y=sigmaMAX)) +
    geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
  geom_boxplot(aes(group=mY), alpha=0.2, notch = TRUE)+
  theme_bw()+coord_cartesian(ylim=c(15,12))+scale_y_reverse()
```


```{r ratio spatial, fig.width=8,fig.height=8}
require(ggmap)
mm <- get_map

mycoord <- c(27,40.5,42,47)
myMap_stamen <- get_map(location=mycoord,source="stamen", maptype="watercolor")
save(myMap_stamen, file="BS_StaMap.Rdata") 
#load(file="BS_StaMap.Rdata")

ms<-ggmap(myMap_stamen, darken = c(0.6,"white"))
ms1<-ms+geom_point(data=subset(sigma_ratio2,(month>3)&(month<11)&(!is.na(ratio))), aes(x=lon,y=lat, color=ratio))+facet_wrap(~month, scale="fixed", ncol=3)+theme_bw()
ms1+scale_color_distiller(palette = 'RdYlBu')#,limits=c(0.9,1.0))
```


```{r ratio_spatial2b}

ddd <- subset(sigma_ratio2,(month %in% c(3,4,5,6,7,8,9,10))&(!is.na(ratio)))
ddd$cutlon <- cut(ddd$lon,breaks = c(27,34.5,42))
ddd$bibi <- factor(interaction(ddd$month,ddd$cutlon), ordered = TRUE)
  
discfigb1<-ggplot(ddd, 
       aes(x = month, y = ratio, color=cutlon, fill=cutlon))+
  theme_bw()+
   geom_boxplot(aes(group= bibi),
                alpha=0.2, notch = TRUE, varwidth = FALSE, position='dodge2')+
  scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12))+
  scale_color_brewer(aesthetics = c("colour", "fill"),
                     type = qual ,palette=MyPal, name="Longitude", labels=c('West','East')) +
  ylab(TeX('$\\sigma_{DCM}/\\sigma_{MLD,max}$'))

discfigb1

```



## and what about light at DCM ? 

```{r paratdcm}
# Attempt to derive PARfraction at the DCM depth

loc <- merge(initPAR, subset(tmp_fitc,select = c("platform","juld","Zmax","Z90T")),by=c("platform","juld"))

PARpartDCM <- function(depth, PAR , Zmax){
  require(pracma)
  #require(nls2)
  if (FilterForPAR(depth,PAR)){
    out    <- try_default({
      d <<- depth[which( !is.na(depth) & PAR>0.1  )]
      P <- PAR[which( !is.na(depth) & PAR>0.1  )]
      
      # ? nls2
      m <<-nls(PAR ~ Att_2band(depth,PAR0,ks0,kl0),
               data = data.frame(depth=depth, PAR=PAR),
               start = p2b_start, 
               lower = p2b_lower,
               upper = p2b_upper,
               algorithm = "port", 
               control = list(maxiter= 1000)
      )
      mcoef  <<- coef(m)
      PAR0   <-  mcoef[1]
      PARcon <- predict(m,data.frame(depth=c(5,Zmax)))  
      PARpartDCM <- PARcon[2]/PAR0
      
      ## Other approach ##
      #PARconB <- approx(x = depth,y=PAR,xout = Zmax)$y
      #PARpartDCM <- PARconB/PAR0
      return(PARpartDCM)},
      DefOut_isoPAR)
  }else{
    out <- DefOut_isoPAR
  }
}

integrated_diags_par2 <- ddply(loc, .(juld,platform), summarize,
                          PARpartDCM = PARpartDCM(depth = depth , PAR = par, Zmax=unique(Zmax))                          )

```

```{r PARatDCM2}
#tmp_fitc<-tmp_fitc[,-which(colnames(tmp_fitc)=="PARpartDCM")]
tmp_fitcl<-merge(tmp_fitc ,integrated_diags_par2, by = c('juld','platform'), all.x = TRUE)

discfig2<-ggplot(tmp_fitcl, aes(x=month, y=PARpartDCM*100)) +
    geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95),
              alpha=0.5,
              color=brewer_pal(palette = MyPal)(2)[2],
              fill=brewer_pal(palette = MyPal)(2)[2])+
  geom_boxplot(aes(group=month), alpha=0.2, notch = TRUE, color=brewer_pal(palette = MyPal)(2)[2],fill=brewer_pal(palette = MyPal)(2)[2])+
  theme_bw()+scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12))+
  scale_y_continuous(breaks = seq(0,5,1), minor_breaks = NULL, limit=c(0,5)) +
  ylab('[% of surface PAR at DCM]')
print(discfig2)

```

```{r PARatDCM2BIS}
#tmp_fitc<-tmp_fitc[,-which(colnames(tmp_fitc)=="PARpartDCM")]
tmp_fitcl<-merge(tmp_fitc ,integrated_diags_par2, by = c('juld','platform'), all.x = TRUE)

tmp_fitcl$cutlon <- cut(tmp_fitcl$lon,breaks = c(27,34.5,42))
tmp_fitcl$bibi         <- factor(interaction(tmp_fitcl$month,tmp_fitcl$cutlon), ordered = TRUE)

# discfigb2<-ggplot(tmp_fitcl, aes(x=cutlon, y=PARpartDCM*100, color=factor(month), fill=factor(month))) +
#   geom_boxplot(aes(group=bibi), alpha=0.2, notch = TRUE)+
#   theme_bw()+#scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12))+
#   scale_y_continuous(breaks = seq(0,5,1), minor_breaks = NULL, limit=c(0,5)) +
#   scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal, name="Month") +
#   ylab('[% of surface PAR at DCM]')
discfigb2<-ggplot(tmp_fitcl, 
       aes(x = month, y = PARpartDCM*100, color=cutlon, fill=cutlon))+
  theme_bw()+
   geom_boxplot(aes(group= bibi),
                alpha=0.2, notch = TRUE, varwidth = FALSE, position='dodge2')+
  scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12))+
  scale_y_continuous(breaks = seq(0,5,1), minor_breaks = NULL, limit=c(0,5)) +
  scale_color_brewer(aesthetics = c("colour", "fill"),
                     type = qual ,palette=MyPal, name="Longitude", labels=c('West','East')) +
  ylab('[% of surface PAR at DCM]')

discfigb2
```


```{r discfig}

 gA <- ggplotGrob(discfig1+geom_text(label='a)', x=3.5, y= 1.05, size=5))
 gB <- ggplotGrob(discfig2+geom_text(label='b)', x=3.5, y= 4.8 , size=5 ))
 
grid::grid.newpage()
grid::grid.draw(rbind(gA, gB))

#grid.arrange(discfig1+geom_text(label='a)', x=3.5, y= 1.05)+theme(axis.line.y.left=element_text(margin = margin(t = 20)),#+ylab('')
 #            discfig2+geom_text(label='b)', x=3.5, y= 4.8),#+ylab('')
#             ncol=1)
```
```{r discfigb}

 gA <- ggplotGrob(discfigb1+geom_text(label='a)', x=3.5, y= 1.05, size=5, color='black'))
 gB <- ggplotGrob(discfigb2+geom_text(label='b)', x=3.5, y= 4.8 , size=5, color='black' ))
 
grid::grid.newpage()
grid::grid.draw(rbind(gA, gB))

#grid.arrange(discfig1+geom_text(label='a)', x=3.5, y= 1.05)+theme(axis.line.y.left=element_text(margin = margin(t = 20)),#+ylab('')
 #            discfig2+geom_text(label='b)', x=3.5, y= 4.8),#+ylab('')
#             ncol=1)
```

```{r ratio_PARatDCM, fig.width=10,fig.height=10, include=FALSE, eval=FALSE}

require(ggmap)
mm <- get_map

mycoord <- c(27,40.5,42,47)
myMap_stamen <- get_map(location=mycoord,source="stamen", maptype="watercolor")
save(myMap_stamen, file="BS_StaMap.Rdata") 
#load(file="BS_StaMap.Rdata")

ms<-ggmap(myMap_stamen, darken = c(0.6,"white"))
ms1<-ms+geom_point(data=subset(tmp_fitc,(month>3)&(month<11)&(!is.na(PARpartDCM))), aes(x=lon,y=lat, color=PARpartDCM*100))+facet_wrap(~month, scale="fixed", ncol=2)+theme_bw()
ms1+scale_color_distiller(palette = 'RdYlBu',limits=c(0,6))

# ms2<-ms+geom_point(data=tmp_fitco, aes(x=lon,y=lat, color=factor(shape)))+
#   facet_wrap(~month, scale="fixed")+theme_bw()
# ms2#+scale_color_discrete(name="", labels=c('non-DCM','DCM'))

```




# Potential Additional sections. 


## Spatial

Numerous Spatial analysis have been done without concluding results beyond "Homogeneous behavior across the central basin".

```{r spatial}

require(ggmap)
mm <- get_map

mycoord <- c(27,40.5,42,47)
myMap_stamen <- get_map(location=mycoord,source="stamen", maptype="watercolor")
save(myMap_stamen, file="BS_StaMap.Rdata") 
#load(file="BS_StaMap.Rdata")

ms<-ggmap(myMap_stamen, darken = c(0.6,"white"))
ms1<-ms+geom_point(data=tmp_fitco, aes(x=lon,y=lat, color=factor(dcm_or_not)))+facet_wrap(~month, scale="fixed")+theme_bw()
ms1+scale_color_discrete(name="", labels=c('non-DCM','DCM'))

# ms2<-ms+geom_point(data=tmp_fitco, aes(x=lon,y=lat, color=factor(shape)))+
#   facet_wrap(~month, scale="fixed")+theme_bw()
# ms2#+scale_color_discrete(name="", labels=c('non-DCM','DCM'))

```

## Inter-annual variability. 

Here we repeat all plots made above, but with single lines marking interannual variability.

```{r, include=FALSE}
require(reshape2)

tmp_zmaxC<- dcast(tmp_zmax,formula = month~variable, fun.aggregate = mean, na.rm=TRUE)
tmp_zmaxA<-melt(tmp_zmaxC, id.vars=c('month'))

P_years_depth <- ggplot(tmp_zmax, aes(x=month, fill=variable, color=variable)) +
    geom_line(data=tmp_zmaxA,aes(y=value),alpha =0.5, size=3)+
      geom_smooth(aes(y=value, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.1))+scale_x_continuous(name='', breaks=c(), labels="")+
  ylab('[m]')+theme_bw()+coord_cartesian(ylim=c(90,0), expand = FALSE)+scale_y_reverse()+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal)+facet_grid(.~year)

P_years_depth
```

```{r, include=FALSE}

tmp_sigC<- dcast(tmp_sig,formula = month~variable, fun.aggregate = mean, na.rm=TRUE)
tmp_sigA<-melt(tmp_sigC, id.vars=c('month'))


P_years_sig <-ggplot(tmp_sig, aes(x=month, fill=variable, color=variable)) +
       geom_line(data=tmp_sigA,aes(y=value),alpha =0.5, size=3)+
      geom_smooth(aes(y=value, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.1))+scale_x_continuous(name='', breaks=c(), labels="")+
  ylab('[kg/m3]')+theme_bw()+coord_cartesian(ylim=c(10,16))+scale_y_reverse()+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal)+facet_grid(.~year)

P_years_sig 

```


```{r, include=FALSE}

tmp_partC<- dcast(tmp_part,formula = month~variable, fun.aggregate = mean, na.rm=TRUE)
tmp_partA<-melt(tmp_partC, id.vars=c('month'))


P_years_part <-ggplot(tmp_part, aes(x=month, fill=variable, color=variable)) +
       geom_line(data=tmp_partA,aes(y=value),alpha =0.5, size=3)+
      geom_smooth(aes(y=value, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.1))+scale_x_continuous(name='', breaks=c(), labels="")+
  ylab('[%]')+theme_bw()+coord_cartesian(ylim=c(0,100))+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal,
                     name='part of tot CHL content', labels=c('above MLD',
                                                              'within a 10m band around DCM',
                                                              'above optical depth'))+
  facet_grid(.~year)

P_years_part


```


```{r, include=FALSE}

tmp_concC<- dcast(tmp_conc,formula = month~variable, fun.aggregate = mean, na.rm=TRUE)
tmp_concA<-melt(tmp_concC, id.vars=c('month'))


P_years_conc <-ggplot(tmp_conc, aes(x=month, fill=variable, color=variable)) +
       geom_line(data=tmp_concA,aes(y=value),alpha =0.5, size=3)+
      geom_smooth(aes(y=value, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.1))+scale_x_continuous(name='', breaks=c(), labels="")+
  ylab('[%]')+theme_bw()+coord_cartesian(ylim=c(0,4))+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal)+
  facet_grid(.~year)

P_years_conc

```


```{r, include=FALSE}
tmp_corrC<- dcast(tmp_corr,formula = month~variable, fun.aggregate = mean, na.rm=TRUE)
tmp_corrA<-melt(tmp_corrC, id.vars=c('month'))


P_years_corr <-ggplot(tmp_corr, aes(x=month, fill=variable, color=variable)) +
       geom_line(data=tmp_corrA,aes(y=value),alpha =0.5, size=3)+
      geom_smooth(aes(y=value, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.1))+scale_x_continuous(name='', breaks=c(), labels="")+
  ylab('[-]')+theme_bw()+coord_cartesian(ylim=c(0,4))+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal)+
  facet_grid(.~year)

P_years_corr
```



```{r, fig.height=15, fig.width=10}
grid.arrange(P_years_depth+theme(legend.position = ''),
             P_years_sig+theme(legend.position = '', strip.background = element_blank(),strip.text.x = element_blank()), 
             P_years_part+theme(legend.position = '', strip.background = element_blank(),strip.text.x = element_blank()),
             P_years_conc+theme(legend.position = '', strip.background = element_blank(),strip.text.x = element_blank()),
             P_years_corr+theme(legend.position = '', strip.background = element_blank(),strip.text.x = element_blank()) ,
             ncol=1)

```



## Quick interannual Anomalies and correlations 
```{r}
# compute annual anomalies ? 
Zmulti<-ddply(tmp_zmax, .(month,year,variable), function(d){
    do<-d
    do$anom = d$value - subset(tmp_zmaxA, (month==d$month[1]) & (variable==d$variable[1]))[,'value']
    return(do)
   })
```


```{r}
Smulti<-ddply(tmp_sig, .(month,year,variable), function(d){
    do<-d
    do$anom = d$value - subset(tmp_sigA, (month==d$month[1]) & (variable==d$variable[1]))[,'value']
    return(do)
   })
```


```{r}
Cmulti<-ddply(tmp_conc, .(month,year,variable), function(d){
    do<-d
    do$anom = d$value - subset(tmp_concA, (month==d$month[1]) & (variable==d$variable[1]))[,'value']
    return(do)
   })

Pmulti<-ddply(tmp_part, .(month,year,variable), function(d){
    do<-d
    do$anom = d$value - subset(tmp_partA, (month==d$month[1]) & (variable==d$variable[1]))[,'value']
    return(do)
   })

Xmulti<-ddply(tmp_corr, .(month,year,variable), function(d){
    do<-d
    do$anom = d$value - subset(tmp_corrA, (month==d$month[1]) & (variable==d$variable[1]))[,'value']
    return(do)
   })
```


```{r}
PA_years_depth <- ggplot(Zmulti, aes(x=month, fill=variable, color=variable)) +
    geom_smooth(aes(y=anom, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.9))+scale_x_continuous(name='', breaks=c(), labels="")+
#  geom_boxplot(aes(y=anom), alpha=.2)+
  ylab('[m]')+theme_bw()+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette='Set1')+facet_grid(variable~year, scales = 'free_y')

PA_years_depth
```


```{r}
PA_years_sig <- ggplot(Smulti, aes(x=month, fill=variable, color=variable)) +
    geom_smooth(aes(y=anom, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.9))+scale_x_continuous(name='', breaks=c(), labels="")+
#  geom_boxplot(aes(y=anom), alpha=.2)+
  ylab('[m]')+theme_bw()+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette='Set1')+facet_grid(variable~year, scales = 'free_y')

PA_years_sig
```


```{r}
PA_years_conc <- ggplot(Cmulti, aes(x=month, fill=variable, color=variable)) +
    geom_smooth(aes(y=anom, group=interaction(year, variable)),stat = 'summary',
             fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.9))+scale_x_continuous(name='', breaks=c(), labels="")+
#  geom_boxplot(aes(y=anom), alpha=.2)+
  ylab('[m]')+theme_bw()+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal)+facet_grid(variable~year, scales = 'free_y')

PA_years_conc
```


```{r}
ZmultiCast <-  dcast(Zmulti,year~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)
ZmultiCastSD <-  dcast(Zmulti,year~variable, value.var = 'anom', fun.aggregate = sd, na.rm=TRUE)
ZmultiCast<-ZmultiCast[,-which(colnames(ZmultiCast)=='Zdemi')]

SmultiCast <-  dcast(Smulti,year~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)

PmultiCast <-  dcast(Pmulti,year~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)

CmultiCast <-  dcast(Cmulti,year~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)

pdt <- merge(ZmultiCast,SmultiCast,by = c('year'))
pdt <- merge(pdt,PmultiCast,by = c('year'))
pdt <- merge(pdt,CmultiCast,by = c('year'))

require(GGally)
ggpairs(pdt,columns = 3:11 )+theme_bw()
```


```{r}
ggcorr(pdt, method = c("everything", "spearman"), geom = 'circle')
```

```{r}
ZmultiCastM   <-  dcast(Zmulti,year+month~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)

ZmultiCastMSD <-  dcast(Zmulti,year+month~variable, value.var = 'anom',
                        fun.aggregate = sd, na.rm=TRUE)
ZmultiCastM   <-      ZmultiCastM[,-which(colnames(ZmultiCastM)=='Zdemi')]

SmultiCastM <-  dcast(Smulti,month+year~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)

PmultiCastM <-  dcast(Pmulti,month+year~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)

CmultiCastM <-  dcast(Cmulti,month+year~variable, value.var = 'anom', fun.aggregate = mean, na.rm=TRUE)

pdtM <- merge(ZmultiCastM,SmultiCastM,by = c('year','month'))
pdtM <- merge(pdtM,PmultiCastM,by = c('year','month'))
pdtM <- merge(pdtM,CmultiCastM,by = c('year','month'))

ggpairs(pdtM,columns = c(3,4,5,9,10,14,16,17,18) )+theme_bw()
```

```{r}
ggcorr(pdtM, method = c("pairwise.complete.obs", "spearman"), geom = 'circle')

```


```{r}
ggplot(pdt,aes(x=Z90B, y=Zmax, color=factor(year)))+
  geom_point(size=4)+
  geom_point(data=pdtM)+theme_bw()
```


```{r}
ggplot(pdt,aes(x=DCMratio, y=Zmax, color=factor(year)))+
  geom_point( size=4)+
  geom_point(data = pdtM, size=1)+
  theme_bw()
```


```{r}
ggplot(pdt,aes(x=DCMratio, y=sigmaMAX, color=factor(year)))+
  geom_point()+theme_bw()
```



```{r}


ggplot(pdtM,aes(x=sigmaMLD, y=sigmaMAX, shape=factor(year), color=factor(month)))+
  geom_point()+theme_bw()+facet_wrap(~month)

```


# Defining ? and compare ? different type of variability. 

How to characterize the Seasonal STD and Annual STD ? 

* Spatial STD, would be the time average of the std within month+year bins
* Seasonal STD, would be the seasonal STD of monthly means. 
* Interannual STD, would be interannual STD of monthly averages, averaged over the months ? 

```{r}
SDMAT<- function(tab_multi,tab_A,tab_all ) {

  # How to characterize the Seasonal STD and Annual STD ? 
  ##     Spatial STD, would be the time average of the std within month+year bins
  ##    Seasonal STD, would be the seasonal STD of monthly means. 
  ## Interannual STD, would be interannual STD of monthly averages, averaged over the months ? 

multiCastMSD <-  dcast(tab_multi,year+month~variable, value.var = 'anom', fun.aggregate = sd, na.rm=TRUE)
mSpatialSD <- dcast(melt(multiCastMSD, id.vars = .(year,month)), variable~.,fun.aggregate = mean, na.rm=TRUE)
colnames(mSpatialSD)<-c('variable','SpatialSD')

mSeasonalSD <- dcast(tab_A, variable~., fun.aggregate = sd, na.rm=TRUE)
colnames(mSeasonalSD)<-c('variable','SeasonalSD')

mC2 <- dcast(tab_all,formula = year+month~variable, fun.aggregate = mean, na.rm=TRUE)
mC3 <- dcast(melt(mC2,id.vars = .(month,year)), formula=variable+month~.,fun.aggregate = sd, na.rm=TRUE )
colnames(mC3)[3]<-"sd"

mAnnualSD <- ddply(mC3, .(variable),summarize,AnnualSD=mean(sd, na.rm=TRUE) )
        
tt<- merge(mSpatialSD,mSeasonalSD, by="variable")
tt<- merge(tt,mAnnualSD , by="variable")

ttNorm <- ddply(tt, .(variable), mutate, 
                OneSD=mean(c(SpatialSD,SeasonalSD,AnnualSD) ),
                SpatialSDNorm  = SpatialSD/OneSD, 
                SeasonalSDNorm = SeasonalSD/OneSD, 
                AnnualSDNorm   = AnnualSD/OneSD) 

return(ttNorm)
}
```


```{r}
sdZ<- SDMAT(Zmulti, tmp_zmaxA, tmp_zmax)

sdS<- SDMAT(Smulti, tmp_sigA , tmp_sig)
sdC<- SDMAT(Cmulti, tmp_concA, tmp_conc)

allsd<-rbind(sdZ, sdS, sdC)


OrderedSDPlot<- function(t,allsd, norm=TRUE){
  if (norm){normstring="Norm"}else{normstring=""}
bibi<- allsd[,c("variable",paste0(t,"SD",normstring))]
bibi$variable<-factor(bibi$variable,
                      levels=bibi$variable[order(bibi[,paste0(t,"SD",normstring)], decreasing = TRUE)], ordered=TRUE)

p<-ggplot(bibi, aes_string(x="variable", y=paste0(t,"SD",normstring)))+
  geom_col(position = 'dodge')+theme_bw()+
  theme(axis.text.x = element_text(angle = 90))
return(p)
}


OrderedSDPlot("Spatial" , allsd, norm=TRUE)
OrderedSDPlot("Annual"  , allsd, norm=TRUE)
OrderedSDPlot("Seasonal", allsd, norm=TRUE)

OrderedSDPlot("Spatial" , sdZ, norm=FALSE)
OrderedSDPlot("Spatial" , sdS, norm=FALSE)

```


```{r}


allsd$variable<-factor(allsd$variable,
                      levels=allsd$variable[order(allsd[,paste0("Spatial","SD","Norm")], decreasing = TRUE)], ordered=TRUE)


ggplot(melt(subset(allsd, select=c("variable","SpatialSDNorm","SeasonalSDNorm","AnnualSDNorm")),
            id.vars=.(variable), variable.name = "Stat"), 
       aes(x=variable, y=value, color=Stat, fill=Stat))+
  geom_col(position = 'dodge')+theme_bw()+
  theme(axis.text.x = element_text(angle = 90))+
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual ,palette=MyPal)


```

## As introduction before processing

### Depth
Fig. [DEPTH] shows the mean Chla content per boxes of X METERS-width over periods of ten days for
all Chla profiles.
Over-imposed is the spatial median of the 1 and 10% isolumes.
**Would be better if computed on the same time-bins, for simplicity**
Those were obtained by fitting simple exponential decay of PAR to derive both PAR0 and attenuation parameters. 
Only about half (**?**) of the profiles contain PAR measurements. 

We observe here : 

* Subsurface CHL maximum from ~day 100 to 280.
* Core CHL is:
    * above 10% from 280 to 100 ; 
    * more or less at 1% (or below) from 100 to 150. 
    * in the upper part of the 1% 10% interval from 150 to 180. 

**It is important to comment on the relevance of the analysis.**
The width of temporal and vertical bins in this processing have been chosen to ensure that the relative error on displayed mean chl content is below 20% all over the plot (or strip parts if not possible).
This also ensure a meaningfull analysis, despite spatial variability in the horizontal dimension which is integrated in our approach. 

![alt text](./mean_chla_Z_context.png)

### SIGMA

Fig. [RHO] follows the same organization than Fig. [DEPTH] using XXX width for the bins. 
Here, we added MLD computed from profiles's T & S following Kara et al. 2008.
In particular, we indicate the range of maximum density of the mixed layer, reached around d50.


We note that : 

* CHL remains above MLDmax all year long

* CHL is
    * above MLD from ~320 to 25.
    * across mld in [25 - 100] and [280-315].
    * below MDL from 100-280.
    

![alt text](./sigma_context.png)



```{r, include=FALSE}


seasonplot<- function(vavar,vname, df=tmp_fitc){
g<-  ggplot(df, aes_string(x="month",y=vavar)) +
    geom_boxplot(aes(group=month), notch = T)+
    geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
              fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
  scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab(vname)+theme_bw()

return(g)
}

P_season_tot <- seasonplot("total_chla","Total Chla Content - [mg/m²]")
P_season_tot

P_season_UpMLD <- seasonplot("UpMLD_chla","Chl above MLD - [mg/m²]")
P_season_UpMLD

P_season_DoMLD <- seasonplot("DoMLD_chla","Chl below MLD - [mg/m²]")
P_season_DoMLD

P_season_RaMLD <- seasonplot("RaMLD_chla","part of TotCHL above MLD - [%]")
P_season_RaMLD

P_season_Vis <- seasonplot("visible_chla","Chl above Optical Depth - [mg/m²]")
P_season_Vis

P_season_VisR <- seasonplot("visible_ratio","Part of visible CHL - [%]")
P_season_VisR

P_season_Zmax <- seasonplot("Zmax","Depth of DCM - [m]")
P_season_Zmax+ylim(c(100,0))

```


## Number of profiles and number of DCM profiles. 

```{r, fig.height=3}
ggplot(tmp_my, aes(x=month, color=factor(year), y=nprof)) +
    geom_line()+theme_bw()+ylab('number of profiles -[%]')+ 
  scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) 

ggplot(tmp_my, aes(x=month, color=factor(year), y=percentage_dcm)) +
    geom_line()+theme_bw()+ylab('percentage of DCM profiles -[%]')+ 
  scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) 
```


This makes much more sense if we integrate 'Other' as DCM profiles. 

```{r percentprofiles}

tmp_my2<-ddply(tmp_fitc, .(month,year), summarize,
                nprof = length(dcm_or_not),
                percentage_dcm =  sum(dcm_or_not)/length(dcm_or_not)*100
                ) 

tmp_myo<-ddply(tmp_fitco, .(month,year), summarize,
                nprof = length(dcm_or_not),
                percentage_dcm =  sum(dcm_or_not)/length(dcm_or_not)*100
                ) 


ggplot(tmp_my, aes(x=month, color=factor(year), y=percentage_dcm)) +
    geom_line()+theme_bw()+ylab('percentage of DCM profiles -[%]')+ 
  scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) 





ggplot(melt(merge(tmp_my2[,c(1,2,4)],tmp_myo[,c(1,2,4)],by=c('month','year')),id.vars=c('month','year')),
       aes(x=month,  y=value, fill=variable, color=variable)) +
  geom_smooth(stat = 'summary',
#              fun.data = median_hilow,
              fun.data = mean_cl_boot,
              fun.args = list(conf.int = 0.95), alpha=0.5)+
    #geom_smooth(data=tmp_myo,stat = 'summary',
#              fun.data = median_hilow,,
     #         fun.data = mean_cl_boot,
      #        fun.args = list(conf.int = 0.95), alpha=0.5, fill='blue', color='blue')+
    theme_bw()+ylab('[%]')+ 
  scale_color_brewer(aesthetics = c("colour", "fill"),type = qual,
                     palette=MyPal,
                     name='percentage of DCM profiles',
                     labels=c('excl. "Others"', 'incl. "Others"'))+
  scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) 

# ggplot(tmp_my2, aes(x=month, y=percentage_dcm)) +
#     geom_line()+geom_smooth(aes(y=value),stat = 'summary',
# #              fun.data = median_hilow,
#               fun.data = mean_cl_boot,
#               fun.args = list(conf.int = 0.95), alpha=0.5)+
#   theme_bw()+ylab('percentage of DCM profiles -[%]')+ 
#   scale_x_continuous(NULL, labels = month.abb, breaks = seq(1,12)) 

```


## Optical Community Index

Optical Community Index use the ratio between backscattering and fluorescence to infer changes in the optical properties of plankton cells, and thereby on planktonic groups. 

Here, we used the depth horizons given above (and derived for each profile) to distinguisch depth ranges :

* Above the CHl Bulk.
* Within the Bulk
* Below.

A significant difference in this index is observed for the layer above the bulk CHL, with much higer BBP/chl ratio. 

The same analysis was attempted considering additional layers (eg. involving a narrow band around DCM), but only surface planktons depicted a 
clear optical community index signature. 



```{r bbratio}
loc <- subset(tmp,
              (fluo>0.1) & (!is.na(sigma))& (!is.na(depth)) & (sigma<15.5),
              select = c('depth','month','fluo','sigma','bbp','juld','platform'))

ll<-merge(loc,tmp_fitc,by=c('juld','platform'))

lld <- ddply(ll,.(juld, platform, depth), transform, 
                DepthRegion= ifelse(depth < Z90T, 'Above',
                                    ifelse(depth < Z90B, 'Within Bulk',
                                           'Below')))

g1 <- ggplot(lld,aes(y=bbp/fluo, fill=factor(DepthRegion)))+#cut(sigma,c(9,13.5,14.5,15.5))
  geom_boxplot(notch = TRUE, outlier.size = 0.2)+
  theme_bw()+
  facet_grid(~cut(month.x, breaks = c(0,2,4,6,8,10,12)))+
  scale_x_discrete()+
  scale_fill_brewer(palette = 3,type='seq',name='Layers - [kg/m3]')



print(g1)
```

## Others profiles

All "other" profiles emerges from DCM profiles, and goes back to DCM profiles. 
The succession between shape is hard to read in z coordinates. 

In sigma coordinates it to emergence of a secondary bloom on top of the (stable) DCM. 
This never last for more than a month (check) and may be induced by local events such as mesoscale dynamics. 

```{r other1}

tmp_fitc$dshape<- paste(tmp_fitc$dcm_or_not,tmp_fitc$shape,sep='_')

tee<-subset(tmp_fitc, select = c("juld","dshape","month","year","platform","dcm_or_not"))

which(tee$dshape=="0_O")

tee[which(tee$dshape=="0_O"),]


ggplot(tee[which(tee$dshape=="0_O")-1,],aes(x=dshape))+geom_bar()+ggtitle("dshape before Others")
ggplot(tee[which(tee$dshape=="0_O")+1,],aes(x=dshape))+geom_bar()+ggtitle("dshape after Others")

ggplot(tee[which(tee$dshape=="0_O")-1,],aes(x=dcm_or_not))+geom_bar()+ggtitle("dshape after Others")

```




```{r other2}
#rr  <- subset(complete_tmp, (platform=="7900591")&(juld>23900)&(juld<24000))
#rr2 <- subset(tmp_fitc, (platform=="7900591")&(juld>23900)&(juld<24000))

##
rr  <- subset(complete_tmp, (platform=="6903240")&(juld>25350)&(juld<25440))
rr2 <- subset(tmp_fitc, (platform=="6903240")&(juld>25350)&(juld<25440))

red<-5

ggplot(rr, aes(y=-depth, x=fluo +(juld-23946)/red, color=factor(juld)))+
  geom_path(size=2)+ylim(c(-100,0))+
  geom_errorbarh(aes(y=-Zmax, xmin=(juld-23946)/red, xmax=1+(juld-23946)/red))+theme_bw()



ggplot(rr, aes(y=-sigma, color=factor(juld)))+
  geom_path(aes(x=fluo+(juld-23946)/red),size=2)+
  geom_errorbarh(data=rr2, aes(y=-sigmaMAX, xmin=(juld-23946)/red, xmax=1+(juld-23946)/red))+theme_bw()

```

```{r other3}
rr  <- subset(complete_tmp, (platform=="7900591")&(juld>23900)&(juld<24000))
rr2 <- subset(tmp_fitc, (platform=="7900591")&(juld>23900)&(juld<24000))

red<-5

ggplot(rr, aes(y=-depth, x=fluo +(juld-23946)/red, color=factor(juld)))+
  geom_path(size=2)+ylim(c(-100,0))+
  geom_errorbarh(aes(y=-Zmax, xmin=(juld-23946)/red, xmax=1+(juld-23946)/red))+theme_bw()



ggplot(rr, aes(y=-sigma, color=factor(juld)))+
  geom_path(aes(x=fluo+(juld-23946)/red),size=2)+
  geom_errorbarh(data=rr2, aes(y=-sigmaMAX, xmin=(juld-23946)/red, xmax=1+(juld-23946)/red))+theme_bw()

```

```{r}
knitr::knit_exit()
```

